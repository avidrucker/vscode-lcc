{
	"$schema": "https://raw.githubusercontent.com/martinring/tmlanguage/master/tmlanguage.json",
	"name": "LCC",
	"patterns": [
		{
			"include": "#keywords"
		},
		{
			"include": "#strings"
		},
		{
			"include": "#comment"
		},
		{
			"include": "#binary"
		},
		{
			"include": "#assembly"
		}
	],
	"repository": {
		"comment": {
			"patterns": [
				{
					"name": "comment.line.lcc",
					"match": ";.*",
					"captures": {
						"0": {
							"patterns": [
								{
									"name": "keyword.todo",
									"match": "(TODO)",
									"captures": {
										"1": {
											"name": "storage.type"
										}
									}
								}
							]
						}
					}
				}
			]
		},
		"assembly": {
			"patterns": [
				{
					"name": "keyword.control.add.immediate.assembly.lcc",
					"_TODOS": "modify match so that it accomodates for labels, modify comments so that they are grayed out immediately following the last character/non-comment token of the instruction",
					"match": "(^[a-zA-Z_$@][a-zA-Z0-9_$@]*:?|^[ ]+[a-zA-Z_$@][a-zA-Z0-9_$@]*:|^[ ]*)?[ ]+(add)[ ]+(r[0-7])[, ]+(r[0-7])[, ]+(-16|-?1[0-5]|-?[1-9]|0)",
					"captures": {
						"1": {
							"name": "variable.name.assembly.lcc"
						},
						"2": {
							"name": "entity.name.function.assembly.lcc"
						},
						"3": {
							"name": "constant.numeric.assembly.lcc"
						},
						"4": {
							"name": "constant.numeric.assembly.lcc"
						},
						"5": {
							"name": "constant.character.assembly.lcc"
						}
					},
					"_match_comment": "start w/ 1 or more spaces, followed by add, followed by 1 or more spaces, followed by r0-r7, followed by 1 or more spaces or commas, followed by r0-r7, followed by 1 or more spaces or commas, followed by a number ranging from -16 to 15",
					"descriptive_name": "Add (Immediate)",
					"description": "dr = sr1 + imm5",
					"syntax": "add dr, sr, imm5",
					"explaination": "The ADD instruction performs an addition operation on the source register and the sign-extended 5-bit immediate value and stores the result in the destination register. The ADD instruction does not affect the condition codes.",
					"flags_set": "nzcv",
					"binary_format": "0001 dr(3) sr1(3) 1 imm5"
				},
				{
					"name": "keyword.control.add.register.assembly.lcc",
					"_TODO": "fix syntax highlighting for add register",
					"match": "(^[a-zA-Z_$@][a-zA-Z0-9_$@]*:?|^[ ]+[a-zA-Z_$@][a-zA-Z0-9_$@]*:|^[ ]*)?[ ]+(add)[ ]+(r[0-7])[, ]+(r[0-7])[, ]+(r[0-7])",
					"captures": {
						"1": {
							"name": "variable.name.assembly.lcc"
						},
						"2": {
							"name": "entity.name.function.assembly.lcc"
						},
						"3": {
							"name": "constant.numeric.assembly.lcc"
						},
						"4": {
							"name": "constant.numeric.assembly.lcc"
						},
						"5": {
							"name": "constant.numeric.assembly.lcc"
						}
					},
					"descriptive_name": "Add (Register)",
					"description": "dr = sr1 + sr2",
					"syntax": "add dr, sr1, sr2",
					"explaination": "The ADD instruction performs an addition operation on the two source registers and stores the result in the destination register. The ADD instruction does not affect the condition codes.",
					"flags_set": "nzcv",
					"binary_format": "0001 dr(3) sr1(3) 000 sr2"
				},
				{
					"name": "keyword.control.and.register.assembly.lcc",
					"match": "(^[a-zA-Z_$@][a-zA-Z0-9_$@]*:?|^[ ]+[a-zA-Z_$@][a-zA-Z0-9_$@]*:|^[ ]*)?[ ]+(and)[ ]+(r[0-7])[, ]+(r[0-7])[, ]+(r[0-7])",
					"captures": {
						"1": {
							"name": "variable.name.assembly.lcc"
						},
						"2": {
							"name": "entity.name.function.assembly.lcc"
						},
						"3": {
							"name": "constant.numeric.assembly.lcc"
						},
						"4": {
							"name": "constant.numeric.assembly.lcc"
						},
						"5": {
							"name": "constant.numeric.assembly.lcc"
						}
					},
					"descriptive_name": "Bitwise AND (Register)",
					"description": "dr = sr1 & sr2",
					"syntax": "and dr, sr1, sr2",
					"explaination": "The AND instruction performs a bitwise AND operation on the two source registers and stores the result in the destination register. The AND instruction does not affect the condition codes.",
					"flags_set": "nz",
					"binary_format": "0101 dr(3) sr1(3) 000 sr2"
				},
				{
					"name": "keyword.control.and.immediate.assembly.lcc",
					"match": "(^[a-zA-Z_$@][a-zA-Z0-9_$@]*:?|^[ ]+[a-zA-Z_$@][a-zA-Z0-9_$@]*:|^[ ]*)?[ ]+(and)[ ]+(r[0-7])[, ]+(r[0-7])[, ]+(-16|-?1[0-5]|-?[1-9]|0)",
					"captures": {
						"1": {
							"name": "variable.name.assembly.lcc"
						},
						"2": {
							"name": "entity.name.function.assembly.lcc"
						},
						"3": {
							"name": "constant.numeric.assembly.lcc"
						},
						"4": {
							"name": "constant.numeric.assembly.lcc"
						},
						"5": {
							"name": "constant.character.assembly.lcc"
						}
					},
					"descriptive_name": "Bitwise AND (Immediate)",
					"description": "dr = sr1 & imm5",
					"syntax": "and dr, sr, imm5",
					"explaination": "The AND instruction performs a bitwise AND operation on the source register and the sign-extended 5-bit immediate value and stores the result in the destination register. The AND instruction does not affect the condition codes.",
					"flags_set": "nz",
					"binary_format": "0101 dr(3) sr1(3) 1 imm5"
				},
				{
					"name": "keyword.control.branch.assembly.lcc",
					"match": "(^[a-zA-Z_$@][a-zA-Z0-9_$@]*:?|^[ ]+[a-zA-Z_$@][a-zA-Z0-9_$@]*:|^[ ]*)[ ]+(br)[ ]+([a-zA-Z_$@][a-zA-Z0-9_$@]*)",
					"captures": {
						"1": {
							"name": "variable.name.assembly.lcc"
						},
						"2": {
							"name": "entity.name.function.assembly.lcc"
						},
						"3": {
							"name": "constant.numeric.assembly.lcc"
						}
					},
					"descriptive_name": "Branch Always",
					"description": "if cc, pc = pc + pcoffset9",
					"syntax": "br label",
					"explaination": "The Branch Always instruction is used to unconditionally branch to a new location in the program, where the destination location is indicated by the label. The Program Counter (PC) is updated to the new location.",
					"flags_set": "",
					"binary_format": "0000 cc(3) pcoffset9[(1) (4) (4)]"
				},
				


				{
					"name": "keyword.control.out.decimal.assembly.lcc",
					"match": "(^[a-zA-Z_$@][a-zA-Z0-9_$@]*:?|^[ ]+[a-zA-Z_$@][a-zA-Z0-9_$@]*:|^[ ]*)[ ]+(dout)[ ]+(r[0-7])",
					"captures": {
						"1": {
							"name": "variable.name.assembly.lcc"
						},
						"2": {
							"name": "entity.name.function.assembly.lcc"
						},
						"3": {
							"name": "constant.numeric.assembly.lcc"
						}
					},
					"descriptive_name": "Decimal Out",
					"description": "display the decimal value in the source register",
					"syntax": "dout sr",
					"explaination": "The DOUT instruction is used to display the value in the source register as a signed decimal number. The value in the source register is displayed on the output device.",
					"flags_set": "",
					"binary_format": "1111 000 sr(3) 000000"
				},
				{
					"name": "keyword.control.halt.assembly.lcc",
					"match": "(^[a-zA-Z_$@][a-zA-Z0-9_$@]*:?|^[ ]+[a-zA-Z_$@][a-zA-Z0-9_$@]*:|^[ ]*)[ ]+(halt)",
					"captures": {
						"1": {
							"name": "variable.name.assembly.lcc"
						},
						"2": {
							"name": "entity.name.function.assembly.lcc"
						}
					},
					"descriptive_name": "Halt",
					"description": "stop the program",
					"syntax": "halt",
					"explaination": "The HALT instruction is used to stop the program. The program stops executing and the processor halts.",
					"flags_set": "",
					"binary_format": "1111 111 000000000"
				},
				{
					"name": "keyword.control.jump.assembly.lcc",
					"_TODOS": "add leading label support",
					"match": "(^[a-zA-Z_$@][a-zA-Z0-9_$@]*:?|^[ ]+[a-zA-Z_$@][a-zA-Z0-9_$@]*:|^[ ]*)[ ]+(jmp)[ ]+([a-zA-Z_$@][a-zA-Z0-9_$@]*)",
					"captures": {
						"1": {
							"name": "variable.name.assembly.lcc"
						},
						"2": {
							"name": "entity.name.function.assembly.lcc"
						},
						"3": {
							"name": "entity.name.function.assembly.lcc"
						}
					},
					"descriptive_name": "Jump",
					"description": "pc = baser + offset6",
					"syntax": "jmp label",
					"explaination": "The JMP instruction is used to jump to a new location in the program. The new location is calculated by adding the value in the baser register to the 6-bit offset field. The result is stored in the program counter (PC), causing the program to continue execution from the new location.",
					"flags_set": "",
					"binary_format": "1100 000 baser(3) offset6(6)"
				},
				{
					"name": "keyword.control.load.assembly.lcc",
					"_TODOS": "add leading label support",
					"match": "(^[a-zA-Z_$@][a-zA-Z0-9_$@]*:?|^[ ]+[a-zA-Z_$@][a-zA-Z0-9_$@]*:|^[ ]*)[ ]+(ld)[ ]+(r[0-7])[, ]+(-16|-?1[0-5]|-?[1-9]|0)",
					"captures": {
						"1": {
							"name": "variable.name.assembly.lcc"
						},
						"2": {
							"name": "entity.name.function.assembly.lcc"
						},
						"3": {
							"name": "variable.register.assembly.lcc"
						},
						"4": {
							"name": "constant.numeric.assembly.lcc"
						}
					},
					"descriptive_name": "Load",
					"description": "dr = mem[pc + pcoffset9]",
					"syntax": "ld dr, imm9",
					"explaination": "The LD instruction is used to load a value from memory into a register. The effective address is calculated by adding the Program Counter (PC) to the 9-bit offset field. The offset field is sign-extended to 16 bits and added to the PC to form the effective address. The contents of memory at the effective address are then loaded into the destination register.",
					"flags_set": "",
					"binary_format": "0010 dr(3) pcoffset9[(1) (4) (4)]"
				},
				{
					"name": "keyword.control.load.relative.assembly.lcc",
					"_TODOS": "modify anything that takes in a register to also be able to take in specially named registers such as sp, fp, and lr (link register), etc., inspect and fix syntax for ldr as needed",
					"match": "(^[a-zA-Z_$@][a-zA-Z0-9_$@]*:?|^[ ]+[a-zA-Z_$@][a-zA-Z0-9_$@]*:|^[ ]*)[ ]+(ldr)[ ]+(r[0-7])[, ]+(r[0-7])[, ]+(r[0-7])",
					"captures": {
						"1": {
							"name": "variable.name.assembly.lcc"
						},
						"2": {
							"name": "entity.name.function.assembly.lcc"
						},
						"3": {
							"name": "variable.register.assembly.lcc"
						},
						"4": {
							"name": "variable.register.assembly.lcc"
						},
						"5": {
							"name": "variable.register.assembly.lcc"
						}
					},
					"descriptive_name": "Load Relative",
					"description": "dr = mem[baser + offset6]",
					"syntax": "ldr dr, baser, offset6",
					"explaination": "The LDR instruction is used to load a value from memory into a register. The effective address is calculated by adding the contents of the base register (baser) to the 6-bit offset field. The contents of memory at the effective address are then loaded into the destination register.",
					"flags_set": "",
					"binary_format": "0110 dr(3) baser(3) offset6(6)"
				},
				{
					"name": "keyword.control.newline.assembly.lcc",
					"_TODOS": "add leading label styling",
					"match": "(^[a-zA-Z_$@][a-zA-Z0-9_$@]*:?|^[ ]+[a-zA-Z_$@][a-zA-Z0-9_$@]*:|^[ ]*)[ ]+(nl)",
					"captures": {
						"1": {
							"name": "variable.name.assembly.lcc"
						},
						"2": {
							"name": "entity.name.function.assembly.lcc"
						}
					},
					"descriptive_name": "Newline",
					"description": "print a newline",
					"syntax": "nl",
					"explaination": "The NL instruction is used to print a newline character to the output device.",
					"flags_set": "",
					"binary_format": "1111 000 000000001"
				},
				{
					"name": "keyword.control.not.assembly.lcc",
					"_TODOS": "add leading label support",
					"match": "(^[a-zA-Z_$@][a-zA-Z0-9_$@]*:?|^[ ]+[a-zA-Z_$@][a-zA-Z0-9_$@]*:|^[ ]*)[ ]+(not)[ ]+(r[0-7])[, ]+(r[0-7])",
					"captures": {
						"1": {
							"name": "variable.name.assembly.lcc"
						},
						"2": {
							"name": "entity.name.function.assembly.lcc"
						},
						"3": {
							"name": "variable.register.assembly.lcc"
						},
						"4": {
							"name": "variable.register.assembly.lcc"
						}
					},
					"descriptive_name": "Bitwise NOT",
					"description": "dr = ~sr1",
					"syntax": "not dr, sr",
					"explaination": "The NOT instruction performs a bitwise NOT operation on the source register and stores the result in the destination register. The NOT instruction does not affect the condition codes.",
					"flags_set": "nz",
					"binary_format": "1001 dr(3) sr1(3) 000000"
				},
				{
					"name": "keyword.control.pop.assembly.lcc",
					"_TODOS": "",
					"match": "(^[a-zA-Z_$@][a-zA-Z0-9_$@]*:?|^[ ]+[a-zA-Z_$@][a-zA-Z0-9_$@]*:|^[ ]*)[ ]+(pop)[ ]+(r[0-7])",
					"captures": {
						"1": {
							"name": "variable.name.assembly.lcc"
						},
						"2": {
							"name": "entity.name.function.assembly.lcc"
						},
						"3": {
							"name": "variable.register.assembly.lcc"
						}
					},
					"descriptive_name": "Pop",
					"description": "dr = mem[sp++];",
					"syntax": "pop dr",
					"explaination": "The POP instruction is used to pop a value from the stack into a register. The value at the memory location pointed to by the stack pointer (SP) is loaded into the destination register (DR), and then the stack pointer is incremented by 1.",
					"flags_set": "",
					"binary_format": "1010 dr(3) 0000 00001"
				}, 
				{
					"name": "keyword.control.push.assembly.lcc",
					"_TODOS": "add leading label support",
					"match": "(^[a-zA-Z_$@][a-zA-Z0-9_$@]*:?|^[ ]+[a-zA-Z_$@][a-zA-Z0-9_$@]*:|^[ ]*)[ ]+(push)[ ]+(r[0-7])",
					"captures": {
						"1": {
							"name": "variable.name.assembly.lcc"
						},
						"2": {
							"name": "entity.name.function.assembly.lcc"
						},
						"3": {
							"name": "variable.register.assembly.lcc"
						}
					},
					"descriptive_name": "Push",
					"description": "mem[--sp] = sr",
					"syntax": "push sr",
					"explaination": "The PUSH instruction is used to push the value of the source register onto the stack. The stack pointer (SP) is decremented by 1 and the value of the source register (SR) is stored in memory at the address pointed to by the stack pointer.",
					"flags_set": "",
					"binary_format": "1010 sr(3) 0000 00000"
				},
				{
					"name": "keyword.control.remainder.assembly.lcc",
					"_TODOS": "add leading label support",
					"match": "(^[a-zA-Z_$@][a-zA-Z0-9_$@]*:?|^[ ]+[a-zA-Z_$@][a-zA-Z0-9_$@]*:|^[ ]*)[ ]+(rem)[ ]+(r[0-7])[, ]+(r[0-7])",
					"captures": {
						"1": {
							"name": "variable.name.assembly.lcc"
						},
						"2": {
							"name": "entity.name.function.assembly.lcc"
						},
						"3": {
							"name": "variable.register.assembly.lcc"
						},
						"4": {
							"name": "variable.register.assembly.lcc"
						}
					},
					"descriptive_name": "Remainder",
					"description": "dr = dr % sr",
					"syntax": "rem dr, sr",
					"explaination": "The REM instruction is used to calculate the remainder of the division operation between the value in the destination register (DR) and the value in the source register (SR). The result is stored in the destination register. The REM instruction does not affect the condition codes.",
					"flags_set": "nz",
					"binary_format": "1010 dr(3) sr(3) 0 01001"
				},
				{
					"name": "keyword.control.rotate.left.assembly.lcc",
					"_TODOS": "add leading label support",
					"_QUESTION": "Does rotate left support negative number inputs, or does it only take unsigned 5 bit numbers?",
					"match": "(^[a-zA-Z_$@][a-zA-Z0-9_$@]*:?|^[ ]+[a-zA-Z_$@][a-zA-Z0-9_$@]*:|^[ ]*)[ ]+(rol)[ ]+(r[0-7])[, ]+(-16|-?1[0-5]|-?[1-9]|0)",
					"captures": {
						"1": {
							"name": "variable.name.assembly.lcc"
						},
						"2": {
							"name": "entity.name.function.assembly.lcc"
						},
						"3": {
							"name": "variable.register.assembly.lcc"
						},
						"4": {
							"name": "constant.numeric.assembly.lcc"
						}
					}, 
					"descriptive_name": "Rotate Left",
					"description": "sr << ct (rotate: bit 15 → bit 0, c=last out)",
					"syntax": "rol sr, ct",
					"explaination": "The ROL instruction performs a left rotation operation on the source register and stores the result in the destination register. The number of rotations is specified by the 5-bit count field. The ROL instruction rotates the bits to the left, with the leftmost bit becoming the rightmost bit, and the last bit rotated out is stored in the carry flag.",
					"flags_set": "nzc",
					"binary_format": "1010 sr(3) ct(4) 00101"
				},
				{
					"name": "keyword.control.move.immediate.assembly.lcc",
					"_TODOS": "modify move immediate's number regex so it matches for 9 bit signed numbers ranging from -256 to 255, TODO: doublecheck and confirm that this is the correct number range, implement leading label support",
					"match": "(^[a-zA-Z_$@][a-zA-Z0-9_$@]*:?|^[ ]+[a-zA-Z_$@][a-zA-Z0-9_$@]*:|^[ ]*)[ ]+(mov)[ ]+(r[0-7])[, ]+(-16|-?1[0-5]|-?[1-9]|0)",
					"captures": {
						"1": {
							"name": "variable.name.assembly.lcc"
						},
						"2": {
							"name": "entity.name.function.assembly.lcc"
						},
						"3": {
							"name": "variable.register.assembly.lcc"
						},
						"4": {
							"name": "constant.character.assembly.lcc"
						}
					},
					"descriptive_name": "Move Immediate",
					"description": "dr = imm9",
					"syntax": "mov dr, imm9",
					"explaination": "The MVI instruction is used to move a 9-bit immediate value into a register. The 9-bit immediate value is stored in the destination register.",
					"flags_set": "",
					"binary_format": "1101 dr(3) imm9(9)"
				},
				{
					"name": "keyword.control.move.relative.assembly.lcc",
					"_TODOS": "add leading label support, modify 4th capture group to instead take in an offset6 number, confirm that this is the correct syntax for move relative",
					"match": "(^[a-zA-Z_$@][a-zA-Z0-9_$@]*:?|^[ ]+[a-zA-Z_$@][a-zA-Z0-9_$@]*:|^[ ]*)[ ]+(mov)[ ]+(r[0-7])[, ]+(r[0-7])",
					"captures": {
						"1": {
							"name": "variable.name.assembly.lcc"
						},
						"2": {
							"name": "entity.name.function.assembly.lcc"
						},
						"3": {
							"name": "variable.register.assembly.lcc"
						},
						"4": {
							"name": "variable.register.assembly.lcc"
						}
					},
					"descriptive_name": "Move Relative",
					"description": "dr = sr",
					"syntax": "mov dr, sr",
					"explaination": "The MVR instruction is used to move a value from memory into a register.",
					"flags_set": "",
					"binary_format": "1010 dr(3) sr(3) 0 01100"
				},
				{
					"name": "keyword.control.shift.right.assembly.lcc",
					"_TODOS": "add leading label support",
					"match": "(^[a-zA-Z_$@][a-zA-Z0-9_$@]*:?|^[ ]+[a-zA-Z_$@][a-zA-Z0-9_$@]*:|^[ ]*)[ ]+(sra)[ ]+(r[0-7])[, ]+(-16|-?1[0-5]|-?[1-9]|0)",
					"captures": {
						"1": {
							"name": "variable.name.assembly.lcc"
						},
						"2": {
							"name": "entity.name.function.assembly.lcc"
						},
						"3": {
							"name": "variable.register.assembly.lcc"
						},
						"4": {
							"name": "constant.numeric.assembly.lcc"
						}
					},
					"descriptive_name": "Shift Right Arithmetic",
					"description": "sr >> ct (sign bit replicated, c=last out)",
					"syntax": "sra sr, ct",
					"explaination": "The SRA instruction performs an arithmetic right shift operation on the source register and stores the result in the destination register. The number of shifts is specified by the 4-bit count field. The SRA instruction replicates the sign bit on the left side of the shifted value, and the last bit shifted out is stored in the carry flag.",
					"flags_set": "nzc",
					"binary_format": "1010 sr(3) ct(4) 00010"
				},
				{
					"name": "keyword.control.directive.zero.assembly.lcc",
					"TODOS": "implement label offsets for both label arguments and label directive declarations (?) see pg 65 in textbook for more info on label offsets",
					"_COMMENT": "directive .zero, preceded by a label, and followed by a numerical value",
					"match": "(^[a-zA-Z_$@][a-zA-Z0-9_$@]*:?|^[ ]+[a-zA-Z_$@][a-zA-Z0-9_$@]*:|^[ ]*)[ ]+(.zero)[ ]+(\\d+)",
					"captures": {
						"1": {
							"name": "variable.name.assembly.lcc"
						},
						"2": {
							"name": "entity.name.tag.assembly.lcc"
						},
						"3": {
							"name": "constant.character.assembly.lcc"
						}
					},
					"descriptive_name": "Zero Directive",
					"description": "store a 16-bit value in memory",
					"syntax": "label: .zero numerical_value",
					"explaination": "Labels are used to mark locations in the program. Directives are used to specify data to be stored in memory. The .ZERO directive is used to store a sequence of zero bytes in memory.",
					"flags_set": "",
					"binary_format": "0000 0000 0000 0000"
				},
				{
					"name": "keyword.control.directive.word.assembly.lcc",
					"TODOS": "implement .start",
					"_COMMENT": "the .word directive, preceded by a label, and followed by a value which could be a number, an ascii character, or another label",
					"match": "(^[a-zA-Z_$@][a-zA-Z0-9_$@]*:?|^[ ]+[a-zA-Z_$@][a-zA-Z0-9_$@]*:|^[ ]*)[ ]+(.word)[ ]+(\\d+|'.'|[a-zA-Z_$@][a-zA-Z0-9_$@]*)",
					"captures": {
						"1": {
							"name": "entity.name.section.assembly.lcc"
						},
						"2": {
							"name": "entity.name.tag.assembly.lcc"
						},
						"3": {
							"name": "constant.character.assembly.lcc"
						}
					},
					"descriptive_name": "Word Directive",
					"description": "store a 16-bit value in memory",
					"syntax": "label: .directive_name value",
					"explaination": "Labels are used to mark locations in the program. Directives are used to specify data to be stored in memory. The .WORD directive is used to store a 16-bit value in memory.",
					"flags_set": "",
					"binary_format": "0000 0000 0000 0000"
				},
				{
					"name": "keyword.control.directive.string.assembly.lcc",
					"TODOS": "split directive into separate capture patterns, because .word alone needs to be able to handle numbers, chars, and labels, .string needs to be able to handle strings, and .zero needs to be able to handle numbers, implement .start",
					"_COMMENT": "directives, such as .word, .zero, .string, etc., preceded by a label, and followed by a value",
					"match": "(^[a-zA-Z_$@][a-zA-Z0-9_$@]*:?|^[ ]+[a-zA-Z_$@][a-zA-Z0-9_$@]*:|^[ ]*)[ ]+(.string)[ ]+(\"[^\"]*\")",
					"captures": {
						"1": {
							"name": "entity.name.section.assembly.lcc"
						},
						"2": {
							"name": "entity.name.tag.assembly.lcc"
						},
						"3": {
							"name": "constant.character.assembly.lcc"
						}
					},
					"descriptive_name": "String Directive",
					"description": "store a 16-bit value in memory",
					"syntax": "label: .directive_name value",
					"explaination": "Labels are used to mark locations in the program. Directives are used to specify data to be stored in memory. The .STRING directive is used to store a string in memory.",
					"flags_set": "",
					"binary_format": "0000 0000 0000 0000"
				},
				{
					"name": "keyword.control.load.effective.address.assembly.lcc",
					"match": "(^[a-zA-Z_$@][a-zA-Z0-9_$@]*:?|^[ ]+[a-zA-Z_$@][a-zA-Z0-9_$@]*:|^[ ]*)?[ ]+(lea)[, ]+(r[0-9])[, ]+([a-zA-Z_$@][a-zA-Z0-9_$@]+)",
					"captures": {
						"1": {
							"name": "variable.name.assembly.lcc"
						},
						"2": {
							"name": "entity.name.function.assembly.lcc"
						},
						"3": {
							"name": "constant.numeric.assembly.lcc"
						},
						"4": {
							"name": "variable.assembly.lcc"
						}
					},
					"descriptive_name": "Load Effective Address",
					"description": "dr = pc + pcoffset9",
					"syntax": "lea dr, label",
					"explaination": "The LEA instruction is used to load the effective address of a label into a register. The effective address is calculated by adding the Program Counter (PC) to the 9-bit offset field. The offset field is sign-extended to 16 bits and added to the PC to form the effective address. The effective address is then loaded into the destination register.",
					"flags_set": "",
					"binary_format": "1110 dr(3) pcoffset9[(1) (4) (4)]"
				},
				{
					"name": "keyword.control.out.string.assembly.lcc",
					"_TODOS": "add leading label support",
					"match": "(^[a-zA-Z_$@][a-zA-Z0-9_$@]*:?|^[ ]+[a-zA-Z_$@][a-zA-Z0-9_$@]*:|^[ ]*)[ ]+(sout)[ ]+(r[0-7])",
					"captures": {
						"1": {
							"name": "variable.name.assembly.lcc"
						},
						"2": {
							"name": "entity.name.function.assembly.lcc"
						},
						"3": {
							"name": "constant.numeric.assembly.lcc"
						}
					},
					"descriptive_name": "String Out",
					"description": "output the string value pointed at by the source register",
					"syntax": "sout sr",
					"explaination": "The SOUT instruction is used to output the value in the source register. The value in the source register is displayed on the output device.",
					"flags_set": "",
					"binary_format": "1111 000 sr(3) 000000"
				},
				{
					"name": "color test",
					"_COMMENT": "this is a helper to quickly test/inspect different textmate names and colors under different themes. _OLD_MATCH holds the previously used match field regex to test eight word captures at a time (not for actual use)",
					"_OLD_MATCH": "([A-Za-z]+)[ ]+([A-Za-z]+)[ ]+([A-Za-z]+)[ ]+([A-Za-z]+)[ ]+([A-Za-z]+)[ ]+([A-Za-z]+)[ ]+([A-Za-z]+)[ ]+([A-Za-z]+)[ ]*",
					"_TEST_STRING": "One two three four five six seven eight",
					"match": "",
					"captures": {
						"1": {
							"name": "variable.name"
						},
						"2": {
							"name": "variable.other"
						},
						"3": {
							"name": "variable.parameter"
						},
						"4": {
							"name": ""
						},
						"5": {
							"name": "support.type.property-name"
						},
						"6": {
							"name": "support.variable"
						},
						"7": {
							"name": "variable"
						},
						"8": {
							"name": "variable.language"
						}
					}
				}					

			]
		},
		"binary": {
			"patterns": [
				{
					"name": "keyword.control.br.lcc",
					"Mnemonic": "br--",
					"match": "^[ ]*0000 [01]{3} ([01]{1} [01]{4} [01]{4})",
					"descriptive_name": "Branch",
					"description": "if cc, pc = pc + pcoffset9",
					"explaination": "The BR instruction is used to conditionally branch to a new location in the program. The condition codes are checked to determine if the branch should be taken. If the condition codes indicate that the branch should be taken, the Program Counter (PC) is updated to the new location. If the condition codes indicate that the branch should not be taken, the PC is not modified and the instruction following the BR instruction is executed.",
					"flags_set": "",
					"binary_format": "0000 cc(3) pcoffset9[(1) (4) (4)]"
				},
				{
					"name": "keyword.control.add.register.lcc",
					"Mnemonic": "add",
					"match": "^[ ]*0001 [01]{3} [01]{3} 000 [01]{3}",
					"descriptive_name": "Add (Register)",
					"description": "dr = sr1 + sr2",
					"explaination": "The ADD instruction performs an addition operation on the two source registers and stores the result in the destination register. The ADD instruction does not affect the condition codes.",
					"flags_set": "nzcv",
					"binary_format": "0001 dr(3) sr1(3) 000 sr2"
				},
				{
					"name": "keyword.control.add.immediate.lcc",
					"Mnemonic": "add",
					"match": "^[ ]*0001 [01]{3} [01]{3} 1 [01]{5}",
					"descriptive_name": "Add (Immediate)",
					"description": "dr = sr1 + imm5",
					"explaination": "The ADD instruction performs an addition operation on the source register and the sign-extended 5-bit immediate value and stores the result in the destination register. The ADD instruction does not affect the condition codes.",
					"flags_set": "nzcv",
					"binary_format": "0001 dr(3) sr1(3) 1 imm5"
				},
				{
					"name": "keyword.control.ld.lcc",
					"Mnemonic": "ld",
					"match": "^[ ]*0010 [01]{3} ([01]{1} [01]{4} [01]{4})",
					"descriptive_name": "Load",
					"description": "dr = mem[pc + pcoffset9]",
					"explaination": "The LD instruction is used to load a value from memory into a register. The effective address is calculated by adding the Program Counter (PC) to the 9-bit offset field. The offset field is sign-extended to 16 bits and added to the PC to form the effective address. The contents of memory at the effective address are then loaded into the destination register.",
					"flags_set": "",
					"binary_format": "0010 dr(3) pcoffset9[(1) (4) (4)]"
				},
				{
					"name": "keyword.control.st.lcc",
					"Mnemonic": "st",
					"match": "^[ ]*0011 [01]{3} ([01]{1} [01]{4} [01]{4})",
					"descriptive_name": "Store",
					"description": "mem[pc + pcoffset9] = sr",
					"explaination": "The ST instruction is used to store the contents of a register into memory. The effective address is calculated by adding the Program Counter (PC) to the 9-bit offset field. The offset field is sign-extended to 16 bits and added to the PC to form the effective address. The contents of the source register are then stored in memory at the effective address.",
					"flags_set": "",
					"binary_format": "0011 sr(3) pcoffset9[(1) (4) (4)]"
				},
				{
					"name": "keyword.control.blcalljsr.lcc",
					"Mnemonic": "bl, call, or jsr",
					"match": "^[ ]*0100 1 ([01]{3} [01]{4} [01]{4})",
					"descriptive_name": "bl, call, or jsr",
					"description": "lr= pc; pc = pc + pcoffset11",
					"explaination": "The BL, CALL, or JSR instruction is used to call a subroutine. The Program Counter (PC) is saved in the Link Register (LR) and the PC is updated to the new location. The new location is calculated by adding the PC to the 11-bit offset field. The offset field is sign-extended to 16 bits and added to the PC to form the new location. The BL, CALL, or JSR instruction is used to call a subroutine. The Program Counter (PC) is saved in the Link Register (LR) and the PC is updated to the new location. The new location is calculated by adding the PC to the 11-bit offset field. The offset field is sign-extended to 16 bits and added to the PC to form the new location.",
					"flags_set": "",
					"binary_format": "0100 1 pcoffset11[(1) (4) (4)]"
				},
				{
					"name": "keyword.control.blrjsrr.lcc",
					"Mnemonic": "blr or jsrr",
					"match": "^[ ]*0100  000 [01]{3} ([01]{6})",
					"descriptive_name": "blr or jsrr",
					"description": "lr = pc; pc = baser + offset6",
					"explaination": "The BLR or JSRR instruction is used to return from a subroutine. The Program Counter (PC) is updated to the contents of the Base Register (BR) and the contents of the Link Register (LR) are loaded into the PC. The BLR or JSRR instruction is used to return from a subroutine. The Program Counter (PC) is updated to the contents of the Base Register (BR) and the contents of the Link Register (LR) are loaded into the PC.",
					"flags_set": "",
					"binary_format": "0100  000  baser(3) offset6(6)"
				},
				{
					"name": "keyword.control.and.register.lcc",
					"Mnemonic": "and",
					"match": "^[ ]*0101 [01]{3} [01]{3} 000 [01]{3}",
					"descriptive_name": "Bitwise AND (Register)",
					"description": "dr = sr1 & sr2",
					"explaination": "The AND instruction performs a bitwise AND operation on the two source registers and stores the result in the destination register. The AND instruction does not affect the condition codes.",
					"flags_set": "nz",
					"binary_format": "0101 dr(3) sr1(3) 000 sr2"
				},
				{
					"name": "keyword.control.and.immediate.lcc",
					"Mnemonic": "and",
					"match": "^[ ]*0101 [01]{3} [01]{3} 1 [01]{5}",
					"descriptive_name": "Bitwise AND (Immediate)",
					"description": "dr = sr1 & imm5",
					"explaination": "The AND instruction performs a bitwise AND operation on the source register and the sign-extended 5-bit immediate value and stores the result in the destination register. The AND instruction does not affect the condition codes.",
					"flags_set": "nz",
					"binary_format": "0101 dr(3) sr1(3) 1 imm5"
				},
				{
					"name": "keyword.control.ldr.lcc",
					"Mnemonic": "ldr",
					"match": "^[ ]*0110 [01]{3} [01]{3} ([01]{6})",
					"descriptive_name": "Load",
					"description": "dr = mem[baser + offset6]",
					"explaination": "The LDR instruction is used to load a value from memory into a register. The effective address is calculated by adding the contents of the base register (baser) to the 6-bit offset field. The contents of memory at the effective address are then loaded into the destination register.",
					"flags_set": "",
					"binary_format": "0110 dr(3) baser(3) offset6(6)"
				},
				{
					"name": "keyword.control.str.lcc",
					"Mnemonic": "str",
					"match": "^[ ]*0111 [01]{3} [01]{3} ([01]{6})",
					"descriptive_name": "Store",
					"description": "mem[baser + offset6] = sr",
					"explaination": "The STR instruction is used to store the contents of a register into memory. The effective address is calculated by adding the contents of the base register (baser) to the 6-bit offset field. The contents of the source register are then stored in memory at the effective address.",
					"flags_set": "",
					"binary_format": "0111 sr(3) baser(3) offset6(6)"
				},
				{
					"name": "keyword.control.cmp.register.lcc",
					"Mnemonic": "cmp",
					"match": "^[ ]*1000 000 [01]{3} 000 [01]{3}",
					"descriptive_name": "Compare (Register)",
					"description": "sr1 - sr2 (set flags)",
					"explaination": "The CMP instruction subtracts the value of the second source register from the value of the first source register and sets the condition flags based on the result. The CMP instruction does not store the result of the subtraction.",
					"flags_set": "nzcv",
					"binary_format": "1000  000 sr1(3) 000 sr2(3)"
				},
				{
					"name": "keyword.control.cmp.immediate.lcc",
					"Mnemonic": "cmp",
					"match": "^[ ]*1000 000 [01]{3} 1 [01]{5}",
					"descriptive_name": "Compare (Immediate)",
					"description": "sr1 - imm5 (set flags)",
					"explaination": "The CMP instruction subtracts the sign-extended 5-bit immediate value from the value of the source register and sets the condition flags based on the result. The CMP instruction does not store the result of the subtraction.",
					"flags_set": "nzcv",
					"binary_format": "1000  000 sr1(3) 1 imm5"
				},
				{
					"name": "keyword.control.not.lcc",
					"Mnemonic": "not",
					"match": "^[ ]*1001 [01]{3} [01]{3} 000000",
					"descriptive_name": "Bitwise NOT",
					"description": "dr = ~sr1",
					"explaination": "The NOT instruction performs a bitwise NOT operation on the source register and stores the result in the destination register. The NOT instruction does not affect the condition codes.",
					"flags_set": "nz",
					"binary_format": "1001 dr(3) sr1(3) 000000"
				},
				{
					"name": "keyword.control.push.lcc",
					"Mnemonic": "push",
					"match": "^[ ]*1010 [01]{3} 0000 00000",
					"descriptive_name": "Push",
					"description": "mem[--sp] = sr",
					"explaination": "The PUSH instruction is used to push the value of the source register onto the stack. The stack pointer (SP) is decremented by 1 and the value of the source register (SR) is stored in memory at the address pointed to by the stack pointer.",
					"flags_set": "",
					"binary_format": "1010 sr(3) 0000 00000"
				},
				{
					"name": "keyword.control.pop.lcc",
					"Mnemonic": "pop",
					"match": "^[ ]*1010 [01]{3} 0000 00001",
					"descriptive_name": "Pop",
					"description": "dr = mem[sp++];",
					"explaination": "The POP instruction is used to pop a value from the stack into a register. The value at the memory location pointed to by the stack pointer (SP) is loaded into the destination register (DR), and then the stack pointer is incremented by 1.",
					"flags_set": "",
					"binary_format": "1010 dr(3) 0000 00001"
				},
				{
					"name": "keyword.control.srl.lcc",
					"Mnemonic": "srl",
					"match": "^[ ]*1010 [01]{3} 00 [01]{4} 00000",
					"descriptive_name": "Shift Right Logical",
					"description": "sr >> ct (0 inserted on left, c=last out)",
					"explaination": "The SRL instruction performs a logical right shift operation on the source register and stores the result in the destination register. The number of shifts is specified by the 4-bit count field. The SRL instruction does not affect the condition codes.",
					"flags_set": "nzc",
					"binary_format": "1010 sr(3) 00 ct(4) 00000"
				},
				{
					"name": "keyword.control.sra.lcc",
					"Mnemonic": "sra",
					"match": "^[ ]*1010 [01]{3} [01]{4} 00011",
					"descriptive_name": "Shift Right Arithmetic",
					"description": "sr >> ct (sign bit replicated, c=last out)",
					"explaination": "The SRA instruction performs an arithmetic right shift operation on the source register and stores the result in the destination register. The number of shifts is specified by the 4-bit count field. The SRA instruction replicates the sign bit on the left side of the shifted value, and the last bit shifted out is stored in the carry flag.",
					"flags_set": "nzc",
					"binary_format": "1010 sr(3) ct(4) 00011"
				},
				{
					"name": "keyword.control.sll.lcc",
					"Mnemonic": "sll",
					"match": "^[ ]*1010 [01]{3} [01]{4} 00100",
					"descriptive_name": "Shift Left Logical",
					"description": "sr << ct (0 inserted on right, c=last out)",
					"explaination": "The SLL instruction performs a logical left shift operation on the source register and stores the result in the destination register. The number of shifts is specified by the 4-bit count field. The SLL instruction does not affect the condition codes.",
					"flags_set": "nzc",
					"binary_format": "1010 sr(3) ct(4) 00100"
				},
				{
					"name": "keyword.control.rol.lcc",
					"Mnemonic": "rol",
					"match": "^[ ]*1010 [01]{3} [01]{4} 00101",
					"descriptive_name": "Rotate Left",
					"description": "sr << ct (rotate: bit 15 → bit 0, c=last out)",
					"explaination": "The ROL instruction performs a left rotation operation on the source register and stores the result in the destination register. The number of rotations is specified by the 5-bit count field. The ROL instruction rotates the bits to the left, with the leftmost bit becoming the rightmost bit, and the last bit rotated out is stored in the carry flag.",
					"flags_set": "nzc",
					"binary_format": "1010 sr(3) ct(4) 00101"
				},
				{
					"name": "keyword.control.ror.lcc",
					"Mnemonic": "ror",
					"match": "^[ ]*1010 [01]{3} [01]{4} 00110",
					"descriptive_name": "Rotate Right",
					"description": "sr >> ct (rotate: bit 0 → bit 15, c=last out)",
					"explaination": "The ROR instruction performs a right rotation operation on the source register and stores the result in the destination register. The number of rotations is specified by the 5-bit count field. The ROR instruction rotates the bits to the right, with the rightmost bit becoming the leftmost bit, and the last bit rotated out is stored in the carry flag.",
					"flags_set": "nzc",
					"binary_format": "1010 sr(3) ct(4) 00110"
				},
				{
					"name": "keyword.control.mul.lcc",
					"Mnemonic": "mul",
					"match": "^[ ]*1010 [01]{3} [01]{3} 0 00111",
					"descriptive_name": "Multiply",
					"description": "dr = dr * sr",
					"explaination": "The MUL instruction is used to multiply the value in the source register (SR) with the value in the destination register (DR) and store the result in the destination register. The MUL instruction does not affect the condition codes.",
					"flags_set": "nz",
					"binary_format": "1010 dr(3) sr(3) 0 00111"
				},
				{
					"name": "keyword.control.div.lcc",
					"Mnemonic": "div",
					"match": "^[ ]*1010 [01]{3} [01]{3} 0 01000",
					"descriptive_name": "Divide",
					"description": "dr = dr / sr",
					"explaination": "The DIV instruction is used to divide the value in the destination register (DR) by the value in the source register (SR) and store the result in the destination register. The DIV instruction does not affect the condition codes.",
					"flags_set": "nz",
					"binary_format": "1010 dr(3) sr(3) 0 01000"
				},
				{
					"name": "keyword.control.rem.lcc",
					"Mnemonic": "rem",
					"match": "^[ ]*1010 [01]{3} [01]{3} 0 01001",
					"descriptive_name": "Remainder",
					"description": "dr = dr % sr",
					"explaination": "The REM instruction is used to calculate the remainder of the division operation between the value in the destination register (DR) and the value in the source register (SR). The result is stored in the destination register. The REM instruction does not affect the condition codes.",
					"flags_set": "nz",
					"binary_format": "1010 dr(3) sr(3) 0 01001"
				},
				{
					"name": "keyword.control.or.lcc",
					"Mnemonic": "or",
					"match": "^[ ]*1010 [01]{3} [01]{3} 0 01010",
					"descriptive_name": "Bitwise OR",
					"description": "dr = dr | sr",
					"explaination": "The OR instruction performs a bitwise OR operation on the source register and the destination register, and stores the result in the destination register. The OR instruction does not affect the condition codes.",
					"flags_set": "nz",
					"binary_format": "1010 dr(3) sr(3) 0 01010"
				},
				{
					"name": "keyword.control.xor.lcc",
					"Mnemonic": "xor",
					"match": "^[ ]*1010 [01]{3} [01]{3} 0 01011",
					"descriptive_name": "Bitwise XOR",
					"description": "dr = dr ^ sr (bitwise exclusive OR)",
					"explaination": "The XOR instruction performs a bitwise exclusive OR operation on the source register and the destination register, and stores the result in the destination register. The XOR instruction does not affect the condition codes.",
					"flags_set": "nz",
					"binary_format": "1010 dr(3) sr(3) 0 01011"
				},
				{
					"name": "keyword.control.mvr.lcc",
					"Mnemonic": "mvr",
					"match": "^[ ]*1010 [01]{3} [01]{3} 0 01100",
					"descriptive_name": "Move Register",
					"description": "dr = sr",
					"explaination": "The MVR instruction is used to move the value in the source register (SR) to the destination register (DR). The value in the source register is copied to the destination register, overwriting the previous value. The MVR instruction does not affect the condition codes.",
					"flags_set": "",
					"binary_format": "1010 dr(3) sr(3) 0 01100"
				},
				{
					"name": "keyword.control.sext.lcc",
					"Mnemonic": "sext",
					"match": "^[ ]*1010 [01]{3} [01]{3} 0 01101",
					"descriptive_name": "Sign Extend",
					"description": "nz dr = sign extended (sr specifies field to extend)",
					"explaination": "The SEXT instruction is used to sign extend the value in the source register (SR) and store the sign extended value in the destination register (DR). The SR specifies the field to extend, and the sign extended value is stored in the DR. The SEXT instruction updates the condition codes based on the result.",
					"flags_set": "nz",
					"binary_format": "1010 dr(3) sr(3) 0 01101"
				},
				{
					"name": "keyword.control.sub.register.lcc",
					"Mnemonic": "sub",
					"match": "^[ ]*1011 [01]{3} [01]{3} [01]{3} 000 [01]{3}",
					"descriptive_name": "Subtract (Register)",
					"description": "dr = sr1 - sr2",
					"explaination": "The SUB instruction is used to subtract the value in the source register 2 (SR2) from the value in the source register 1 (SR1), and store the result in the destination register (DR). The SUB instruction updates the condition codes based on the result.",
					"flags_set": "nzcv",
					"binary_format": "1011 dr(3) sr1(3) 000 sr2(3)"
				},
				{
					"name": "keyword.control.sub.immediate.lcc",
					"Mnemonic": "sub",
					"match": "^[ ]*1011 [01]{3} [01]{3} 1 [01]{5}",
					"descriptive_name": "Subtract (Immediate)",
					"description": "dr = sr1 - imm5",
					"explaination": "The SUB instruction is used to subtract the immediate value (imm5) from the value in the source register (SR1), and store the result in the destination register (DR). The SUB instruction updates the condition codes based on the result.",
					"flags_set": "nzcv",
					"binary_format": "1011 dr(3) sr1(3) 1 imm5(5)"
				},
				{
					"name": "keyword.control.jmp.lcc",
					"Mnemonic": "jmp",
					"match": "^[ ]*1100 000 [01]{3} ([01]{6})",
					"descriptive_name": "Jump",
					"description": "pc = baser + offset6",
					"explaination": "The JMP instruction is used to jump to a new location in the program. The new location is calculated by adding the value in the baser register to the 6-bit offset field. The result is stored in the program counter (PC), causing the program to continue execution from the new location.",
					"flags_set": "",
					"binary_format": "1100 000 baser(3) offset6(6)"
				},
				{
					"name": "keyword.control.ret.lcc",
					"Mnemonic": "ret",
					"match": "^[ ]*1100 000 111 ([01]{6})",
					"descriptive_name": "Return",
					"description": "pc = lr + offset6",
					"explaination": "The RET instruction is used to return from a subroutine. The new location is calculated by adding the value in the link register (LR) to the 6-bit offset field. The result is stored in the program counter (PC), causing the program to continue execution from the new location.",
					"flags_set": "",
					"binary_format": "1100 000 111 offset6(6)"
				},
				{
					"name": "keyword.control.mvi.immediate.lcc",
					"Mnemonic": "mvi",
					"match": "^[ ]*1101 [01]{3} ([01]{1} [01]{4} [01]{4})",
					"descriptive_name": "Move Immediate",
					"description": "dr = imm9",
					"explaination": "The MVI instruction is used to move an immediate value (imm9) into the destination register (DR). The immediate value is stored directly in the destination register. The MVI instruction does not affect the condition codes.",
					"flags_set": "",
					"binary_format": "1101 dr(3) imm9[(1) (4) (4)]"
				},
				{
					"name": "keyword.control.lea.lcc",
					"Mnemonic": "lea",
					"match": "^[ ]*1110 [01]{3} ([01]{1} [01]{4} [01]{4})",
					"descriptive_name": "Load Effective Address",
					"description": "dr = pc + pcoffset9",
					"explaination": "The LEA instruction is used to load the effective address of a memory location into a register. The effective address is calculated by adding the Program Counter (PC) to the 9-bit offset field. The offset field is sign-extended to 16 bits and added to the PC to form the effective address. The effective address is then stored in the destination register.",
					"flags_set": "",
					"binary_format": "1110 dr(3) pcoffset9[(1) (4) (4)]"
				},
				{
					"name": "keyword.control.halt.lcc",
					"Mnemonic": "halt",
					"match": "^[ ]*1111 000 0000 00000",
					"descriptive_name": "Halt",
					"description": "Stop execution, return to OS",
					"explaination": "The HALT instruction is used to stop the execution of the program and return control to the operating system.",
					"flags_set": "none",
					"binary_format": "1111 000 0000 00000"
				},
				{
					"name": "keyword.control.nl.lcc",
					"Mnemonic": "nl",
					"match": "^[ ]*1111 000 0000 00001",
					"descriptive_name": "Output newline",
					"description": "Output a newline character",
					"explaination": "The NL instruction is used to output a newline character. It can be used to add a line break in the output.",
					"flags_set": "none",
					"binary_format": "1111 000 0000 00001"
				},
				{
					"name": "keyword.control.dout.lcc",
					"Mnemonic": "dout",
					"match": "^[ ]*1111 [01]{3} 0000 00010",
					"descriptive_name": "Display signed number in sr in decimal",
					"description": "Display the signed number in the source register (SR) in decimal format",
					"explaination": "The DOUT instruction is used to display the signed number in the source register (SR) in decimal format.",
					"flags_set": "none",
					"binary_format": "1111 sr(3) 0000 00010"
				},
				{
					"name": "keyword.control.udout.lcc",
					"Mnemonic": "udout",
					"match": "^[ ]*1111 [01]{3} 0000 00011",
					"descriptive_name": "Display unsigned number in sr in decimal",
					"description": "Display the unsigned number in the source register (SR) in decimal format",
					"explaination": "The UDOUT instruction is used to display the unsigned number in the source register (SR) in decimal format.",
					"flags_set": "none",
					"binary_format": "1111 sr(3) 0000 00011"
				},
				{
					"name": "keyword.control.hout.lcc",
					"Mnemonic": "hout",
					"match": "^[ ]*1111 [01]{3} 0000 00100",
					"descriptive_name": "Display number in sr in hex",
					"description": "Display the number in the source register (SR) in hexadecimal format",
					"explaination": "The HOUT instruction is used to display the number in the source register (SR) in hexadecimal format.",
					"flags_set": "none",
					"binary_format": "1111 sr(3) 0000 00100"
				},
				{
					"name": "keyword.control.aout.lcc",
					"Mnemonic": "aout",
					"match": "^[ ]*1111 [01]{3} 0000 00101",
					"descriptive_name": "Display ASCII character in sr",
					"description": "Display the ASCII character in the source register (SR)",
					"explaination": "The AOUT instruction is used to display the ASCII character in the source register (SR).",
					"flags_set": "none",
					"binary_format": "1111 sr(3) 0000 00101"
				},
				{
					"name": "keyword.control.sout.lcc",
					"Mnemonic": "sout",
					"match": "^[ ]*1111 [01]{3} 0000 00110",
					"descriptive_name": "Display string sr points to",
					"description": "Display the string that the source register (SR) points to",
					"explaination": "The SOUT instruction is used to display the string that the source register (SR) points to.",
					"flags_set": "none",
					"binary_format": "1111 sr(3) 0000 00110"
				},
				{
					"name": "keyword.control.din.lcc",
					"Mnemonic": "din",
					"match": "^[ ]*1111 [01]{3} 0000 00111",
					"descriptive_name": "Read decimal number from keyboard into dr",
					"description": "Read a decimal number from the keyboard and store it in the destination register (DR)",
					"explaination": "The DIN instruction is used to read a decimal number from the keyboard and store it in the destination register (DR).",
					"flags_set": "none",
					"binary_format": "1111 dr(3) 0000 00111"
				},
				{
					"name": "keyword.control.hin.lcc",
					"Mnemonic": "hin",
					"match": "^[ ]*1111 [01]{3} 0000 01000",
					"descriptive_name": "Read hex number from keyboard into dr",
					"description": "Read a hexadecimal number from the keyboard and store it in the destination register (DR)",
					"explaination": "The HIN instruction is used to read a hexadecimal number from the keyboard and store it in the destination register (DR).",
					"flags_set": "none",
					"binary_format": "1111 dr(3) 0000 01000"
				},
				{
					"name": "keyword.control.ain.lcc",
					"Mnemonic": "ain",
					"match": "^[ ]*1111 [01]{3} 00000 1001",
					"descriptive_name": "Read ASCII character from keyboard into dr",
					"description": "Read an ASCII character from the keyboard and store it in the destination register (DR)",
					"explaination": "The AIN instruction is used to read an ASCII character from the keyboard and store it in the destination register (DR).",
					"flags_set": "none",
					"binary_format": "1111 dr(3) 0000 01001"
				},
				{
					"name": "keyword.control.sin.lcc",
					"Mnemonic": "sin",
					"match": "^[ ]*1111 [01]{3} 0000 01010",
					"descriptive_name": "Input string into buffer sr points to",
					"description": "Read a string from the keyboard and store it in the buffer that the source register (SR) points to",
					"explaination": "The SIN instruction is used to read a string from the keyboard and store it in the buffer that the source register (SR) points to.",
					"flags_set": "none",
					"binary_format": "1111 sr(3) 0000 01010"
				},
				{
					"name": "constant.numeric.binary.lcc",
					"match": "^[ ]*([01]{4} [01]{4} [01]{4} [01]{4})",
					"descriptive_name": "Binary Number",
					"explaination": "This is a 4 byte binary number. 2s complement",
					"binary_format": "(4) (4) (4) (4)"
				}
			]
		},
		"keywords": {
			"patterns": [
				{
	
				}
			]
		},
		"strings": {
			"name": "string.quoted.double.lcc",
			"begin": "\"",
			"end": "\"",
			"patterns": [
				{
					"name": "constant.character.escape.lcc",
					"match": "\\\\."
				}
			]
		}
	},
	"scopeName": "source.lcc"
}